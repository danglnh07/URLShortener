// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: url.sql

package db

import (
	"context"
	"time"
)

const createURL = `-- name: CreateURL :one
INSERT INTO url(original_url)
VALUES ($1)
RETURNING id, original_url, time_created
`

func (q *Queries) CreateURL(ctx context.Context, originalUrl string) (Url, error) {
	row := q.db.QueryRowContext(ctx, createURL, originalUrl)
	var i Url
	err := row.Scan(&i.ID, &i.OriginalUrl, &i.TimeCreated)
	return i, err
}

const listURL = `-- name: ListURL :many
SELECT u.id, u.original_url, u.time_created, (SELECT COUNT(*) FROM visitor v WHERE v.url_id = u.id) AS total_visitors
FROM url u
OFFSET $1
LIMIT $2
`

type ListURLParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type ListURLRow struct {
	ID            int32     `json:"id"`
	OriginalUrl   string    `json:"original_url"`
	TimeCreated   time.Time `json:"time_created"`
	TotalVisitors int64     `json:"total_visitors"`
}

func (q *Queries) ListURL(ctx context.Context, arg ListURLParams) ([]ListURLRow, error) {
	rows, err := q.db.QueryContext(ctx, listURL, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListURLRow{}
	for rows.Next() {
		var i ListURLRow
		if err := rows.Scan(
			&i.ID,
			&i.OriginalUrl,
			&i.TimeCreated,
			&i.TotalVisitors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
